// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'downloader.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$MyDownloaderStatus {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noStart,
    required TResult Function() running,
    required TResult Function(MyNetworkItemPendingType field0) pending,
    required TResult Function(String field0) error,
    required TResult Function() finished,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noStart,
    TResult? Function()? running,
    TResult? Function(MyNetworkItemPendingType field0)? pending,
    TResult? Function(String field0)? error,
    TResult? Function()? finished,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noStart,
    TResult Function()? running,
    TResult Function(MyNetworkItemPendingType field0)? pending,
    TResult Function(String field0)? error,
    TResult Function()? finished,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyDownloaderStatus_NoStart value) noStart,
    required TResult Function(MyDownloaderStatus_Running value) running,
    required TResult Function(MyDownloaderStatus_Pending value) pending,
    required TResult Function(MyDownloaderStatus_Error value) error,
    required TResult Function(MyDownloaderStatus_Finished value) finished,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyDownloaderStatus_NoStart value)? noStart,
    TResult? Function(MyDownloaderStatus_Running value)? running,
    TResult? Function(MyDownloaderStatus_Pending value)? pending,
    TResult? Function(MyDownloaderStatus_Error value)? error,
    TResult? Function(MyDownloaderStatus_Finished value)? finished,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyDownloaderStatus_NoStart value)? noStart,
    TResult Function(MyDownloaderStatus_Running value)? running,
    TResult Function(MyDownloaderStatus_Pending value)? pending,
    TResult Function(MyDownloaderStatus_Error value)? error,
    TResult Function(MyDownloaderStatus_Finished value)? finished,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MyDownloaderStatusCopyWith<$Res> {
  factory $MyDownloaderStatusCopyWith(
          MyDownloaderStatus value, $Res Function(MyDownloaderStatus) then) =
      _$MyDownloaderStatusCopyWithImpl<$Res, MyDownloaderStatus>;
}

/// @nodoc
class _$MyDownloaderStatusCopyWithImpl<$Res, $Val extends MyDownloaderStatus>
    implements $MyDownloaderStatusCopyWith<$Res> {
  _$MyDownloaderStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$MyDownloaderStatus_NoStartImplCopyWith<$Res> {
  factory _$$MyDownloaderStatus_NoStartImplCopyWith(
          _$MyDownloaderStatus_NoStartImpl value,
          $Res Function(_$MyDownloaderStatus_NoStartImpl) then) =
      __$$MyDownloaderStatus_NoStartImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MyDownloaderStatus_NoStartImplCopyWithImpl<$Res>
    extends _$MyDownloaderStatusCopyWithImpl<$Res,
        _$MyDownloaderStatus_NoStartImpl>
    implements _$$MyDownloaderStatus_NoStartImplCopyWith<$Res> {
  __$$MyDownloaderStatus_NoStartImplCopyWithImpl(
      _$MyDownloaderStatus_NoStartImpl _value,
      $Res Function(_$MyDownloaderStatus_NoStartImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MyDownloaderStatus_NoStartImpl implements MyDownloaderStatus_NoStart {
  const _$MyDownloaderStatus_NoStartImpl();

  @override
  String toString() {
    return 'MyDownloaderStatus.noStart()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyDownloaderStatus_NoStartImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noStart,
    required TResult Function() running,
    required TResult Function(MyNetworkItemPendingType field0) pending,
    required TResult Function(String field0) error,
    required TResult Function() finished,
  }) {
    return noStart();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noStart,
    TResult? Function()? running,
    TResult? Function(MyNetworkItemPendingType field0)? pending,
    TResult? Function(String field0)? error,
    TResult? Function()? finished,
  }) {
    return noStart?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noStart,
    TResult Function()? running,
    TResult Function(MyNetworkItemPendingType field0)? pending,
    TResult Function(String field0)? error,
    TResult Function()? finished,
    required TResult orElse(),
  }) {
    if (noStart != null) {
      return noStart();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyDownloaderStatus_NoStart value) noStart,
    required TResult Function(MyDownloaderStatus_Running value) running,
    required TResult Function(MyDownloaderStatus_Pending value) pending,
    required TResult Function(MyDownloaderStatus_Error value) error,
    required TResult Function(MyDownloaderStatus_Finished value) finished,
  }) {
    return noStart(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyDownloaderStatus_NoStart value)? noStart,
    TResult? Function(MyDownloaderStatus_Running value)? running,
    TResult? Function(MyDownloaderStatus_Pending value)? pending,
    TResult? Function(MyDownloaderStatus_Error value)? error,
    TResult? Function(MyDownloaderStatus_Finished value)? finished,
  }) {
    return noStart?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyDownloaderStatus_NoStart value)? noStart,
    TResult Function(MyDownloaderStatus_Running value)? running,
    TResult Function(MyDownloaderStatus_Pending value)? pending,
    TResult Function(MyDownloaderStatus_Error value)? error,
    TResult Function(MyDownloaderStatus_Finished value)? finished,
    required TResult orElse(),
  }) {
    if (noStart != null) {
      return noStart(this);
    }
    return orElse();
  }
}

abstract class MyDownloaderStatus_NoStart implements MyDownloaderStatus {
  const factory MyDownloaderStatus_NoStart() = _$MyDownloaderStatus_NoStartImpl;
}

/// @nodoc
abstract class _$$MyDownloaderStatus_RunningImplCopyWith<$Res> {
  factory _$$MyDownloaderStatus_RunningImplCopyWith(
          _$MyDownloaderStatus_RunningImpl value,
          $Res Function(_$MyDownloaderStatus_RunningImpl) then) =
      __$$MyDownloaderStatus_RunningImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MyDownloaderStatus_RunningImplCopyWithImpl<$Res>
    extends _$MyDownloaderStatusCopyWithImpl<$Res,
        _$MyDownloaderStatus_RunningImpl>
    implements _$$MyDownloaderStatus_RunningImplCopyWith<$Res> {
  __$$MyDownloaderStatus_RunningImplCopyWithImpl(
      _$MyDownloaderStatus_RunningImpl _value,
      $Res Function(_$MyDownloaderStatus_RunningImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MyDownloaderStatus_RunningImpl implements MyDownloaderStatus_Running {
  const _$MyDownloaderStatus_RunningImpl();

  @override
  String toString() {
    return 'MyDownloaderStatus.running()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyDownloaderStatus_RunningImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noStart,
    required TResult Function() running,
    required TResult Function(MyNetworkItemPendingType field0) pending,
    required TResult Function(String field0) error,
    required TResult Function() finished,
  }) {
    return running();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noStart,
    TResult? Function()? running,
    TResult? Function(MyNetworkItemPendingType field0)? pending,
    TResult? Function(String field0)? error,
    TResult? Function()? finished,
  }) {
    return running?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noStart,
    TResult Function()? running,
    TResult Function(MyNetworkItemPendingType field0)? pending,
    TResult Function(String field0)? error,
    TResult Function()? finished,
    required TResult orElse(),
  }) {
    if (running != null) {
      return running();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyDownloaderStatus_NoStart value) noStart,
    required TResult Function(MyDownloaderStatus_Running value) running,
    required TResult Function(MyDownloaderStatus_Pending value) pending,
    required TResult Function(MyDownloaderStatus_Error value) error,
    required TResult Function(MyDownloaderStatus_Finished value) finished,
  }) {
    return running(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyDownloaderStatus_NoStart value)? noStart,
    TResult? Function(MyDownloaderStatus_Running value)? running,
    TResult? Function(MyDownloaderStatus_Pending value)? pending,
    TResult? Function(MyDownloaderStatus_Error value)? error,
    TResult? Function(MyDownloaderStatus_Finished value)? finished,
  }) {
    return running?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyDownloaderStatus_NoStart value)? noStart,
    TResult Function(MyDownloaderStatus_Running value)? running,
    TResult Function(MyDownloaderStatus_Pending value)? pending,
    TResult Function(MyDownloaderStatus_Error value)? error,
    TResult Function(MyDownloaderStatus_Finished value)? finished,
    required TResult orElse(),
  }) {
    if (running != null) {
      return running(this);
    }
    return orElse();
  }
}

abstract class MyDownloaderStatus_Running implements MyDownloaderStatus {
  const factory MyDownloaderStatus_Running() = _$MyDownloaderStatus_RunningImpl;
}

/// @nodoc
abstract class _$$MyDownloaderStatus_PendingImplCopyWith<$Res> {
  factory _$$MyDownloaderStatus_PendingImplCopyWith(
          _$MyDownloaderStatus_PendingImpl value,
          $Res Function(_$MyDownloaderStatus_PendingImpl) then) =
      __$$MyDownloaderStatus_PendingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({MyNetworkItemPendingType field0});
}

/// @nodoc
class __$$MyDownloaderStatus_PendingImplCopyWithImpl<$Res>
    extends _$MyDownloaderStatusCopyWithImpl<$Res,
        _$MyDownloaderStatus_PendingImpl>
    implements _$$MyDownloaderStatus_PendingImplCopyWith<$Res> {
  __$$MyDownloaderStatus_PendingImplCopyWithImpl(
      _$MyDownloaderStatus_PendingImpl _value,
      $Res Function(_$MyDownloaderStatus_PendingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$MyDownloaderStatus_PendingImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as MyNetworkItemPendingType,
    ));
  }
}

/// @nodoc

class _$MyDownloaderStatus_PendingImpl implements MyDownloaderStatus_Pending {
  const _$MyDownloaderStatus_PendingImpl(this.field0);

  @override
  final MyNetworkItemPendingType field0;

  @override
  String toString() {
    return 'MyDownloaderStatus.pending(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyDownloaderStatus_PendingImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyDownloaderStatus_PendingImplCopyWith<_$MyDownloaderStatus_PendingImpl>
      get copyWith => __$$MyDownloaderStatus_PendingImplCopyWithImpl<
          _$MyDownloaderStatus_PendingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noStart,
    required TResult Function() running,
    required TResult Function(MyNetworkItemPendingType field0) pending,
    required TResult Function(String field0) error,
    required TResult Function() finished,
  }) {
    return pending(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noStart,
    TResult? Function()? running,
    TResult? Function(MyNetworkItemPendingType field0)? pending,
    TResult? Function(String field0)? error,
    TResult? Function()? finished,
  }) {
    return pending?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noStart,
    TResult Function()? running,
    TResult Function(MyNetworkItemPendingType field0)? pending,
    TResult Function(String field0)? error,
    TResult Function()? finished,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyDownloaderStatus_NoStart value) noStart,
    required TResult Function(MyDownloaderStatus_Running value) running,
    required TResult Function(MyDownloaderStatus_Pending value) pending,
    required TResult Function(MyDownloaderStatus_Error value) error,
    required TResult Function(MyDownloaderStatus_Finished value) finished,
  }) {
    return pending(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyDownloaderStatus_NoStart value)? noStart,
    TResult? Function(MyDownloaderStatus_Running value)? running,
    TResult? Function(MyDownloaderStatus_Pending value)? pending,
    TResult? Function(MyDownloaderStatus_Error value)? error,
    TResult? Function(MyDownloaderStatus_Finished value)? finished,
  }) {
    return pending?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyDownloaderStatus_NoStart value)? noStart,
    TResult Function(MyDownloaderStatus_Running value)? running,
    TResult Function(MyDownloaderStatus_Pending value)? pending,
    TResult Function(MyDownloaderStatus_Error value)? error,
    TResult Function(MyDownloaderStatus_Finished value)? finished,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending(this);
    }
    return orElse();
  }
}

abstract class MyDownloaderStatus_Pending implements MyDownloaderStatus {
  const factory MyDownloaderStatus_Pending(
      final MyNetworkItemPendingType field0) = _$MyDownloaderStatus_PendingImpl;

  MyNetworkItemPendingType get field0;
  @JsonKey(ignore: true)
  _$$MyDownloaderStatus_PendingImplCopyWith<_$MyDownloaderStatus_PendingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MyDownloaderStatus_ErrorImplCopyWith<$Res> {
  factory _$$MyDownloaderStatus_ErrorImplCopyWith(
          _$MyDownloaderStatus_ErrorImpl value,
          $Res Function(_$MyDownloaderStatus_ErrorImpl) then) =
      __$$MyDownloaderStatus_ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$MyDownloaderStatus_ErrorImplCopyWithImpl<$Res>
    extends _$MyDownloaderStatusCopyWithImpl<$Res,
        _$MyDownloaderStatus_ErrorImpl>
    implements _$$MyDownloaderStatus_ErrorImplCopyWith<$Res> {
  __$$MyDownloaderStatus_ErrorImplCopyWithImpl(
      _$MyDownloaderStatus_ErrorImpl _value,
      $Res Function(_$MyDownloaderStatus_ErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$MyDownloaderStatus_ErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$MyDownloaderStatus_ErrorImpl implements MyDownloaderStatus_Error {
  const _$MyDownloaderStatus_ErrorImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'MyDownloaderStatus.error(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyDownloaderStatus_ErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyDownloaderStatus_ErrorImplCopyWith<_$MyDownloaderStatus_ErrorImpl>
      get copyWith => __$$MyDownloaderStatus_ErrorImplCopyWithImpl<
          _$MyDownloaderStatus_ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noStart,
    required TResult Function() running,
    required TResult Function(MyNetworkItemPendingType field0) pending,
    required TResult Function(String field0) error,
    required TResult Function() finished,
  }) {
    return error(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noStart,
    TResult? Function()? running,
    TResult? Function(MyNetworkItemPendingType field0)? pending,
    TResult? Function(String field0)? error,
    TResult? Function()? finished,
  }) {
    return error?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noStart,
    TResult Function()? running,
    TResult Function(MyNetworkItemPendingType field0)? pending,
    TResult Function(String field0)? error,
    TResult Function()? finished,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyDownloaderStatus_NoStart value) noStart,
    required TResult Function(MyDownloaderStatus_Running value) running,
    required TResult Function(MyDownloaderStatus_Pending value) pending,
    required TResult Function(MyDownloaderStatus_Error value) error,
    required TResult Function(MyDownloaderStatus_Finished value) finished,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyDownloaderStatus_NoStart value)? noStart,
    TResult? Function(MyDownloaderStatus_Running value)? running,
    TResult? Function(MyDownloaderStatus_Pending value)? pending,
    TResult? Function(MyDownloaderStatus_Error value)? error,
    TResult? Function(MyDownloaderStatus_Finished value)? finished,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyDownloaderStatus_NoStart value)? noStart,
    TResult Function(MyDownloaderStatus_Running value)? running,
    TResult Function(MyDownloaderStatus_Pending value)? pending,
    TResult Function(MyDownloaderStatus_Error value)? error,
    TResult Function(MyDownloaderStatus_Finished value)? finished,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class MyDownloaderStatus_Error implements MyDownloaderStatus {
  const factory MyDownloaderStatus_Error(final String field0) =
      _$MyDownloaderStatus_ErrorImpl;

  String get field0;
  @JsonKey(ignore: true)
  _$$MyDownloaderStatus_ErrorImplCopyWith<_$MyDownloaderStatus_ErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MyDownloaderStatus_FinishedImplCopyWith<$Res> {
  factory _$$MyDownloaderStatus_FinishedImplCopyWith(
          _$MyDownloaderStatus_FinishedImpl value,
          $Res Function(_$MyDownloaderStatus_FinishedImpl) then) =
      __$$MyDownloaderStatus_FinishedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MyDownloaderStatus_FinishedImplCopyWithImpl<$Res>
    extends _$MyDownloaderStatusCopyWithImpl<$Res,
        _$MyDownloaderStatus_FinishedImpl>
    implements _$$MyDownloaderStatus_FinishedImplCopyWith<$Res> {
  __$$MyDownloaderStatus_FinishedImplCopyWithImpl(
      _$MyDownloaderStatus_FinishedImpl _value,
      $Res Function(_$MyDownloaderStatus_FinishedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MyDownloaderStatus_FinishedImpl implements MyDownloaderStatus_Finished {
  const _$MyDownloaderStatus_FinishedImpl();

  @override
  String toString() {
    return 'MyDownloaderStatus.finished()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyDownloaderStatus_FinishedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noStart,
    required TResult Function() running,
    required TResult Function(MyNetworkItemPendingType field0) pending,
    required TResult Function(String field0) error,
    required TResult Function() finished,
  }) {
    return finished();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? noStart,
    TResult? Function()? running,
    TResult? Function(MyNetworkItemPendingType field0)? pending,
    TResult? Function(String field0)? error,
    TResult? Function()? finished,
  }) {
    return finished?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noStart,
    TResult Function()? running,
    TResult Function(MyNetworkItemPendingType field0)? pending,
    TResult Function(String field0)? error,
    TResult Function()? finished,
    required TResult orElse(),
  }) {
    if (finished != null) {
      return finished();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyDownloaderStatus_NoStart value) noStart,
    required TResult Function(MyDownloaderStatus_Running value) running,
    required TResult Function(MyDownloaderStatus_Pending value) pending,
    required TResult Function(MyDownloaderStatus_Error value) error,
    required TResult Function(MyDownloaderStatus_Finished value) finished,
  }) {
    return finished(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyDownloaderStatus_NoStart value)? noStart,
    TResult? Function(MyDownloaderStatus_Running value)? running,
    TResult? Function(MyDownloaderStatus_Pending value)? pending,
    TResult? Function(MyDownloaderStatus_Error value)? error,
    TResult? Function(MyDownloaderStatus_Finished value)? finished,
  }) {
    return finished?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyDownloaderStatus_NoStart value)? noStart,
    TResult Function(MyDownloaderStatus_Running value)? running,
    TResult Function(MyDownloaderStatus_Pending value)? pending,
    TResult Function(MyDownloaderStatus_Error value)? error,
    TResult Function(MyDownloaderStatus_Finished value)? finished,
    required TResult orElse(),
  }) {
    if (finished != null) {
      return finished(this);
    }
    return orElse();
  }
}

abstract class MyDownloaderStatus_Finished implements MyDownloaderStatus {
  const factory MyDownloaderStatus_Finished() =
      _$MyDownloaderStatus_FinishedImpl;
}
