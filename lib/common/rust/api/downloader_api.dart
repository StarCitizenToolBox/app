// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_task_status`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Initialize the download manager session
void downloaderInit({required String downloadDir}) => RustLib.instance.api
    .crateApiDownloaderApiDownloaderInit(downloadDir: downloadDir);

/// Check if the downloader is initialized
bool downloaderIsInitialized() =>
    RustLib.instance.api.crateApiDownloaderApiDownloaderIsInitialized();

/// Add a torrent from bytes (e.g., .torrent file content)
Future<BigInt> downloaderAddTorrent({
  required List<int> torrentBytes,
  String? outputFolder,
  List<String>? trackers,
}) => RustLib.instance.api.crateApiDownloaderApiDownloaderAddTorrent(
  torrentBytes: torrentBytes,
  outputFolder: outputFolder,
  trackers: trackers,
);

/// Add a torrent from a magnet link
Future<BigInt> downloaderAddMagnet({
  required String magnetLink,
  String? outputFolder,
  List<String>? trackers,
}) => RustLib.instance.api.crateApiDownloaderApiDownloaderAddMagnet(
  magnetLink: magnetLink,
  outputFolder: outputFolder,
  trackers: trackers,
);

/// Add a torrent from URL (HTTP download not supported, only torrent file URLs)
Future<BigInt> downloaderAddUrl({
  required String url,
  String? outputFolder,
  List<String>? trackers,
}) => RustLib.instance.api.crateApiDownloaderApiDownloaderAddUrl(
  url: url,
  outputFolder: outputFolder,
  trackers: trackers,
);

/// Pause a download task
Future<void> downloaderPause({required BigInt taskId}) =>
    RustLib.instance.api.crateApiDownloaderApiDownloaderPause(taskId: taskId);

/// Resume a download task
Future<void> downloaderResume({required BigInt taskId}) =>
    RustLib.instance.api.crateApiDownloaderApiDownloaderResume(taskId: taskId);

/// Remove a download task
Future<void> downloaderRemove({
  required BigInt taskId,
  required bool deleteFiles,
}) => RustLib.instance.api.crateApiDownloaderApiDownloaderRemove(
  taskId: taskId,
  deleteFiles: deleteFiles,
);

/// Get information about a specific task
Future<DownloadTaskInfo> downloaderGetTaskInfo({required BigInt taskId}) =>
    RustLib.instance.api.crateApiDownloaderApiDownloaderGetTaskInfo(
      taskId: taskId,
    );

/// Get all tasks
Future<List<DownloadTaskInfo>> downloaderGetAllTasks() =>
    RustLib.instance.api.crateApiDownloaderApiDownloaderGetAllTasks();

/// Get global statistics
Future<DownloadGlobalStat> downloaderGetGlobalStats() =>
    RustLib.instance.api.crateApiDownloaderApiDownloaderGetGlobalStats();

/// Check if a task with given name exists
Future<bool> downloaderIsNameInTask({required String name}) => RustLib
    .instance
    .api
    .crateApiDownloaderApiDownloaderIsNameInTask(name: name);

/// Pause all tasks
Future<void> downloaderPauseAll() =>
    RustLib.instance.api.crateApiDownloaderApiDownloaderPauseAll();

/// Resume all tasks
Future<void> downloaderResumeAll() =>
    RustLib.instance.api.crateApiDownloaderApiDownloaderResumeAll();

/// Stop the downloader session
Future<void> downloaderStop() =>
    RustLib.instance.api.crateApiDownloaderApiDownloaderStop();

/// Global statistics
class DownloadGlobalStat {
  final BigInt downloadSpeed;
  final BigInt uploadSpeed;
  final BigInt numActive;
  final BigInt numWaiting;

  const DownloadGlobalStat({
    required this.downloadSpeed,
    required this.uploadSpeed,
    required this.numActive,
    required this.numWaiting,
  });

  static Future<DownloadGlobalStat> default_() =>
      RustLib.instance.api.crateApiDownloaderApiDownloadGlobalStatDefault();

  @override
  int get hashCode =>
      downloadSpeed.hashCode ^
      uploadSpeed.hashCode ^
      numActive.hashCode ^
      numWaiting.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DownloadGlobalStat &&
          runtimeType == other.runtimeType &&
          downloadSpeed == other.downloadSpeed &&
          uploadSpeed == other.uploadSpeed &&
          numActive == other.numActive &&
          numWaiting == other.numWaiting;
}

/// Download task information
class DownloadTaskInfo {
  final BigInt id;
  final String name;
  final DownloadTaskStatus status;
  final BigInt totalBytes;
  final BigInt downloadedBytes;
  final BigInt uploadedBytes;
  final BigInt downloadSpeed;
  final BigInt uploadSpeed;
  final double progress;
  final BigInt numPeers;
  final String outputFolder;

  const DownloadTaskInfo({
    required this.id,
    required this.name,
    required this.status,
    required this.totalBytes,
    required this.downloadedBytes,
    required this.uploadedBytes,
    required this.downloadSpeed,
    required this.uploadSpeed,
    required this.progress,
    required this.numPeers,
    required this.outputFolder,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      status.hashCode ^
      totalBytes.hashCode ^
      downloadedBytes.hashCode ^
      uploadedBytes.hashCode ^
      downloadSpeed.hashCode ^
      uploadSpeed.hashCode ^
      progress.hashCode ^
      numPeers.hashCode ^
      outputFolder.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DownloadTaskInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          status == other.status &&
          totalBytes == other.totalBytes &&
          downloadedBytes == other.downloadedBytes &&
          uploadedBytes == other.uploadedBytes &&
          downloadSpeed == other.downloadSpeed &&
          uploadSpeed == other.uploadSpeed &&
          progress == other.progress &&
          numPeers == other.numPeers &&
          outputFolder == other.outputFolder;
}

/// Download task status
enum DownloadTaskStatus { initializing, live, paused, error, finished }
