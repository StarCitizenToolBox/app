// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Check if the URL scheme is already registered with the correct executable path
Future<ApplinksRegistrationResult> checkApplinksRegistration({
  required String scheme,
}) => RustLib.instance.api.crateApiApplinksApiCheckApplinksRegistration(
  scheme: scheme,
);

/// Register URL scheme in Windows registry
/// This will create or update the registry keys for the custom URL scheme
///
/// # Arguments
/// * `scheme` - The URL scheme to register (e.g., "sctoolbox")
/// * `app_name` - Optional application display name (e.g., "SCToolBox"). If provided,
///                the registry will show "URL:{app_name} Protocol" as the scheme description.
Future<ApplinksRegistrationResult> registerApplinks({
  required String scheme,
  String? appName,
}) => RustLib.instance.api.crateApiApplinksApiRegisterApplinks(
  scheme: scheme,
  appName: appName,
);

/// Unregister URL scheme from Windows registry
Future<ApplinksRegistrationResult> unregisterApplinks({
  required String scheme,
}) =>
    RustLib.instance.api.crateApiApplinksApiUnregisterApplinks(scheme: scheme);

/// Applinks URL scheme registration result
class ApplinksRegistrationResult {
  /// Whether registration was successful
  final bool success;

  /// Detailed message about the operation
  final String message;

  /// Whether the registry was modified (false if already configured correctly)
  final bool wasModified;

  const ApplinksRegistrationResult({
    required this.success,
    required this.message,
    required this.wasModified,
  });

  @override
  int get hashCode =>
      success.hashCode ^ message.hashCode ^ wasModified.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ApplinksRegistrationResult &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          message == other.message &&
          wasModified == other.wasModified;
}
