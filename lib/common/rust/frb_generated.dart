// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/asar_api.dart';
import 'api/downloader_api.dart';
import 'api/http_api.dart';
import 'api/ort_api.dart';
import 'api/rs_process.dart';
import 'api/unp4k_api.dart';
import 'api/webview_api.dart';
import 'api/win32_api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'http_package.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -1903117367;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'rust',
        ioDirectory: 'rust/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiWin32ApiAddNvmePatch();

  Future<bool> crateApiWin32ApiCheckNvmePatchStatus();

  Future<void> crateApiOrtApiClearAllModels();

  Future<void> crateApiWin32ApiCreateDesktopShortcut({
    required String targetPath,
    required String shortcutName,
  });

  Future<void> crateApiUnp4KApiDcbClose();

  Future<void> crateApiUnp4KApiDcbExportToDisk({
    required String outputPath,
    required String dcbPath,
    required bool merge,
  });

  Future<BigInt> crateApiUnp4KApiDcbGetRecordCount();

  Future<List<DcbRecordItem>> crateApiUnp4KApiDcbGetRecordList();

  Future<bool> crateApiUnp4KApiDcbIsDataforge({required List<int> data});

  Future<void> crateApiUnp4KApiDcbOpen({required List<int> data});

  Future<String> crateApiUnp4KApiDcbRecordToXml({required String path});

  Future<String> crateApiUnp4KApiDcbRecordToXmlByIndex({required BigInt index});

  Future<List<DcbSearchResult>> crateApiUnp4KApiDcbSearchAll({
    required String query,
    required BigInt maxResults,
  });

  Future<List<String>> crateApiHttpApiDnsLookupIps({required String host});

  Future<List<String>> crateApiHttpApiDnsLookupTxt({required String host});

  Future<DownloadGlobalStat> crateApiDownloaderApiDownloadGlobalStatDefault();

  Future<BigInt> crateApiDownloaderApiDownloaderAddMagnet({
    required String magnetLink,
    String? outputFolder,
    List<String>? trackers,
  });

  Future<BigInt> crateApiDownloaderApiDownloaderAddTorrent({
    required List<int> torrentBytes,
    String? outputFolder,
    List<String>? trackers,
  });

  Future<BigInt> crateApiDownloaderApiDownloaderAddUrl({
    required String url,
    String? outputFolder,
    List<String>? trackers,
  });

  void crateApiDownloaderApiDownloaderClearCompletedTasksCache();

  Future<List<DownloadTaskInfo>> crateApiDownloaderApiDownloaderGetAllTasks();

  List<DownloadTaskInfo>
  crateApiDownloaderApiDownloaderGetCompletedTasksCache();

  Future<DownloadGlobalStat> crateApiDownloaderApiDownloaderGetGlobalStats();

  Future<DownloadTaskInfo> crateApiDownloaderApiDownloaderGetTaskInfo({
    required BigInt taskId,
  });

  Future<bool> crateApiDownloaderApiDownloaderHasActiveTasks();

  bool crateApiDownloaderApiDownloaderHasPendingSessionTasks({
    required String workingDir,
  });

  Future<void> crateApiDownloaderApiDownloaderInit({
    required String workingDir,
    required String defaultDownloadDir,
    int? uploadLimitBps,
    int? downloadLimitBps,
  });

  bool crateApiDownloaderApiDownloaderIsInitialized();

  Future<bool> crateApiDownloaderApiDownloaderIsNameInTask({
    required String name,
    bool? downloadingOnly,
  });

  Future<void> crateApiDownloaderApiDownloaderPause({required BigInt taskId});

  Future<void> crateApiDownloaderApiDownloaderPauseAll();

  Future<void> crateApiDownloaderApiDownloaderRemove({
    required BigInt taskId,
    required bool deleteFiles,
  });

  Future<int> crateApiDownloaderApiDownloaderRemoveCompletedTasks();

  Future<void> crateApiDownloaderApiDownloaderResume({required BigInt taskId});

  Future<void> crateApiDownloaderApiDownloaderResumeAll();

  Future<void> crateApiDownloaderApiDownloaderShutdown();

  Future<void> crateApiDownloaderApiDownloaderStop();

  Future<void> crateApiDownloaderApiDownloaderUpdateSpeedLimits({
    int? uploadLimitBps,
    int? downloadLimitBps,
  });

  Future<RustHttpResponse> crateApiHttpApiFetch({
    required MyMethod method,
    required String url,
    Map<String, String>? headers,
    Uint8List? inputData,
    String? withIpAddress,
    bool? withCustomDns,
  });

  Future<int> crateApiWin32ApiGetDiskPhysicalSectorSize({
    required String driveLetter,
  });

  Future<String?> crateApiHttpApiGetFasterUrl({
    required List<String> urls,
    String? pathSuffix,
  });

  Future<String> crateApiWin32ApiGetGpuInfoFromRegistry();

  Future<int> crateApiWin32ApiGetNumberOfLogicalProcessors();

  Future<List<ProcessInfo>> crateApiWin32ApiGetProcessListByName({
    required String processName,
  });

  Future<int> crateApiWin32ApiGetProcessPidByName({
    required String processName,
  });

  Future<RsiLauncherAsarData> crateApiAsarApiGetRsiLauncherAsarData({
    required String asarPath,
  });

  Future<SystemInfo> crateApiWin32ApiGetSystemInfo();

  Future<BigInt> crateApiWin32ApiGetSystemMemorySizeGb();

  Future<int> crateApiWin32ApiKillProcessByName({required String processName});

  Future<void> crateApiOrtApiLoadTranslationModel({
    required String modelPath,
    required String modelKey,
    required String quantizationSuffix,
    required bool useXnnpack,
  });

  Future<void> crateApiWin32ApiOpenDirWithExplorer({
    required String path,
    required bool isFile,
  });

  Future<void> crateApiUnp4KApiP4KClose();

  Future<void> crateApiUnp4KApiP4KExtractToDisk({
    required String filePath,
    required String outputPath,
  });

  Future<Uint8List> crateApiUnp4KApiP4KExtractToMemory({
    required String filePath,
  });

  Future<List<P4kFileItem>> crateApiUnp4KApiP4KGetAllFiles();

  Future<BigInt> crateApiUnp4KApiP4KGetFileCount();

  Future<void> crateApiUnp4KApiP4KOpen({required String p4KPath});

  Future<void> crateApiWin32ApiRemoveNvmePatch();

  Future<String> crateApiWin32ApiResolveShortcut({required String lnkPath});

  Future<void> crateApiAsarApiRsiLauncherAsarDataWriteMainJs({
    required RsiLauncherAsarData that,
    required List<int> content,
  });

  Future<void> crateApiWin32ApiRunAsAdmin({
    required String program,
    required String args,
  });

  Future<void> crateApiWin32ApiSendNotify({
    String? summary,
    String? body,
    String? appName,
    String? appId,
  });

  Future<void> crateApiHttpApiSetDefaultHeader({
    required Map<String, String> headers,
  });

  Future<bool> crateApiWin32ApiSetForegroundWindow({
    required String windowName,
  });

  Stream<RsProcessStreamData> crateApiRsProcessStart({
    required String executable,
    required List<String> arguments,
    required String workingDirectory,
  });

  Future<void> crateApiWin32ApiStartProcess({
    required String program,
    required List<String> args,
  });

  Future<String> crateApiOrtApiTranslateText({
    required String modelKey,
    required String text,
  });

  Future<List<String>> crateApiOrtApiTranslateTextBatch({
    required String modelKey,
    required List<String> texts,
  });

  Future<void> crateApiOrtApiUnloadTranslationModel({required String modelKey});

  Future<WebViewConfiguration> crateApiWebviewApiWebViewConfigurationDefault();

  Future<WebViewNavigationState>
  crateApiWebviewApiWebViewNavigationStateDefault();

  void crateApiWebviewApiWebviewClose({required String id});

  String crateApiWebviewApiWebviewCreate({
    required WebViewConfiguration config,
  });

  void crateApiWebviewApiWebviewExecuteScript({
    required String id,
    required String script,
  });

  WebViewNavigationState crateApiWebviewApiWebviewGetState({
    required String id,
  });

  void crateApiWebviewApiWebviewGoBack({required String id});

  void crateApiWebviewApiWebviewGoForward({required String id});

  bool crateApiWebviewApiWebviewIsClosed({required String id});

  List<String> crateApiWebviewApiWebviewListAll();

  void crateApiWebviewApiWebviewNavigate({
    required String id,
    required String url,
  });

  List<WebViewEvent> crateApiWebviewApiWebviewPollEvents({required String id});

  void crateApiWebviewApiWebviewReload({required String id});

  void crateApiWebviewApiWebviewSetVisibility({
    required String id,
    required bool visible,
  });

  void crateApiWebviewApiWebviewSetWindowPosition({
    required String id,
    required int x,
    required int y,
  });

  void crateApiWebviewApiWebviewSetWindowSize({
    required String id,
    required int width,
    required int height,
  });

  void crateApiWebviewApiWebviewStop({required String id});

  Future<void> crateApiRsProcessWrite({
    required int rsPid,
    required String data,
  });
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiWin32ApiAddNvmePatch() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__win32_api__add_nvme_patch(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiAddNvmePatchConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiAddNvmePatchConstMeta =>
      const TaskConstMeta(debugName: "add_nvme_patch", argNames: []);

  @override
  Future<bool> crateApiWin32ApiCheckNvmePatchStatus() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__win32_api__check_nvme_patch_status(
            port_,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiCheckNvmePatchStatusConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiCheckNvmePatchStatusConstMeta =>
      const TaskConstMeta(debugName: "check_nvme_patch_status", argNames: []);

  @override
  Future<void> crateApiOrtApiClearAllModels() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__ort_api__clear_all_models(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiOrtApiClearAllModelsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiOrtApiClearAllModelsConstMeta =>
      const TaskConstMeta(debugName: "clear_all_models", argNames: []);

  @override
  Future<void> crateApiWin32ApiCreateDesktopShortcut({
    required String targetPath,
    required String shortcutName,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(targetPath);
          var arg1 = cst_encode_String(shortcutName);
          return wire.wire__crate__api__win32_api__create_desktop_shortcut(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiCreateDesktopShortcutConstMeta,
        argValues: [targetPath, shortcutName],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiCreateDesktopShortcutConstMeta =>
      const TaskConstMeta(
        debugName: "create_desktop_shortcut",
        argNames: ["targetPath", "shortcutName"],
      );

  @override
  Future<void> crateApiUnp4KApiDcbClose() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__unp4k_api__dcb_close(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiDcbCloseConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiDcbCloseConstMeta =>
      const TaskConstMeta(debugName: "dcb_close", argNames: []);

  @override
  Future<void> crateApiUnp4KApiDcbExportToDisk({
    required String outputPath,
    required String dcbPath,
    required bool merge,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(outputPath);
          var arg1 = cst_encode_String(dcbPath);
          var arg2 = cst_encode_bool(merge);
          return wire.wire__crate__api__unp4k_api__dcb_export_to_disk(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiDcbExportToDiskConstMeta,
        argValues: [outputPath, dcbPath, merge],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiDcbExportToDiskConstMeta =>
      const TaskConstMeta(
        debugName: "dcb_export_to_disk",
        argNames: ["outputPath", "dcbPath", "merge"],
      );

  @override
  Future<BigInt> crateApiUnp4KApiDcbGetRecordCount() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__unp4k_api__dcb_get_record_count(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_usize,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiDcbGetRecordCountConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiDcbGetRecordCountConstMeta =>
      const TaskConstMeta(debugName: "dcb_get_record_count", argNames: []);

  @override
  Future<List<DcbRecordItem>> crateApiUnp4KApiDcbGetRecordList() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__unp4k_api__dcb_get_record_list(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_dcb_record_item,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiDcbGetRecordListConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiDcbGetRecordListConstMeta =>
      const TaskConstMeta(debugName: "dcb_get_record_list", argNames: []);

  @override
  Future<bool> crateApiUnp4KApiDcbIsDataforge({required List<int> data}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_list_prim_u_8_loose(data);
          return wire.wire__crate__api__unp4k_api__dcb_is_dataforge(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiUnp4KApiDcbIsDataforgeConstMeta,
        argValues: [data],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiDcbIsDataforgeConstMeta =>
      const TaskConstMeta(debugName: "dcb_is_dataforge", argNames: ["data"]);

  @override
  Future<void> crateApiUnp4KApiDcbOpen({required List<int> data}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_list_prim_u_8_loose(data);
          return wire.wire__crate__api__unp4k_api__dcb_open(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiDcbOpenConstMeta,
        argValues: [data],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiDcbOpenConstMeta =>
      const TaskConstMeta(debugName: "dcb_open", argNames: ["data"]);

  @override
  Future<String> crateApiUnp4KApiDcbRecordToXml({required String path}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(path);
          return wire.wire__crate__api__unp4k_api__dcb_record_to_xml(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiDcbRecordToXmlConstMeta,
        argValues: [path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiDcbRecordToXmlConstMeta =>
      const TaskConstMeta(debugName: "dcb_record_to_xml", argNames: ["path"]);

  @override
  Future<String> crateApiUnp4KApiDcbRecordToXmlByIndex({
    required BigInt index,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_usize(index);
          return wire.wire__crate__api__unp4k_api__dcb_record_to_xml_by_index(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiDcbRecordToXmlByIndexConstMeta,
        argValues: [index],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiDcbRecordToXmlByIndexConstMeta =>
      const TaskConstMeta(
        debugName: "dcb_record_to_xml_by_index",
        argNames: ["index"],
      );

  @override
  Future<List<DcbSearchResult>> crateApiUnp4KApiDcbSearchAll({
    required String query,
    required BigInt maxResults,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(query);
          var arg1 = cst_encode_usize(maxResults);
          return wire.wire__crate__api__unp4k_api__dcb_search_all(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_dcb_search_result,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiDcbSearchAllConstMeta,
        argValues: [query, maxResults],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiDcbSearchAllConstMeta =>
      const TaskConstMeta(
        debugName: "dcb_search_all",
        argNames: ["query", "maxResults"],
      );

  @override
  Future<List<String>> crateApiHttpApiDnsLookupIps({required String host}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(host);
          return wire.wire__crate__api__http_api__dns_lookup_ips(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiHttpApiDnsLookupIpsConstMeta,
        argValues: [host],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiHttpApiDnsLookupIpsConstMeta =>
      const TaskConstMeta(debugName: "dns_lookup_ips", argNames: ["host"]);

  @override
  Future<List<String>> crateApiHttpApiDnsLookupTxt({required String host}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(host);
          return wire.wire__crate__api__http_api__dns_lookup_txt(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiHttpApiDnsLookupTxtConstMeta,
        argValues: [host],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiHttpApiDnsLookupTxtConstMeta =>
      const TaskConstMeta(debugName: "dns_lookup_txt", argNames: ["host"]);

  @override
  Future<DownloadGlobalStat> crateApiDownloaderApiDownloadGlobalStatDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire
              .wire__crate__api__downloader_api__download_global_stat_default(
                port_,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_download_global_stat,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDownloaderApiDownloadGlobalStatDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloadGlobalStatDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "download_global_stat_default",
        argNames: [],
      );

  @override
  Future<BigInt> crateApiDownloaderApiDownloaderAddMagnet({
    required String magnetLink,
    String? outputFolder,
    List<String>? trackers,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(magnetLink);
          var arg1 = cst_encode_opt_String(outputFolder);
          var arg2 = cst_encode_opt_list_String(trackers);
          return wire.wire__crate__api__downloader_api__downloader_add_magnet(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_usize,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderAddMagnetConstMeta,
        argValues: [magnetLink, outputFolder, trackers],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderAddMagnetConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_add_magnet",
        argNames: ["magnetLink", "outputFolder", "trackers"],
      );

  @override
  Future<BigInt> crateApiDownloaderApiDownloaderAddTorrent({
    required List<int> torrentBytes,
    String? outputFolder,
    List<String>? trackers,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_list_prim_u_8_loose(torrentBytes);
          var arg1 = cst_encode_opt_String(outputFolder);
          var arg2 = cst_encode_opt_list_String(trackers);
          return wire.wire__crate__api__downloader_api__downloader_add_torrent(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_usize,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderAddTorrentConstMeta,
        argValues: [torrentBytes, outputFolder, trackers],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderAddTorrentConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_add_torrent",
        argNames: ["torrentBytes", "outputFolder", "trackers"],
      );

  @override
  Future<BigInt> crateApiDownloaderApiDownloaderAddUrl({
    required String url,
    String? outputFolder,
    List<String>? trackers,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(url);
          var arg1 = cst_encode_opt_String(outputFolder);
          var arg2 = cst_encode_opt_list_String(trackers);
          return wire.wire__crate__api__downloader_api__downloader_add_url(
            port_,
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_usize,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderAddUrlConstMeta,
        argValues: [url, outputFolder, trackers],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderAddUrlConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_add_url",
        argNames: ["url", "outputFolder", "trackers"],
      );

  @override
  void crateApiDownloaderApiDownloaderClearCompletedTasksCache() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire
              .wire__crate__api__downloader_api__downloader_clear_completed_tasks_cache();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiDownloaderApiDownloaderClearCompletedTasksCacheConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDownloaderApiDownloaderClearCompletedTasksCacheConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_clear_completed_tasks_cache",
        argNames: [],
      );

  @override
  Future<List<DownloadTaskInfo>> crateApiDownloaderApiDownloaderGetAllTasks() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire
              .wire__crate__api__downloader_api__downloader_get_all_tasks(
                port_,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_download_task_info,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderGetAllTasksConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderGetAllTasksConstMeta =>
      const TaskConstMeta(debugName: "downloader_get_all_tasks", argNames: []);

  @override
  List<DownloadTaskInfo>
  crateApiDownloaderApiDownloaderGetCompletedTasksCache() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire
              .wire__crate__api__downloader_api__downloader_get_completed_tasks_cache();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_download_task_info,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiDownloaderApiDownloaderGetCompletedTasksCacheConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDownloaderApiDownloaderGetCompletedTasksCacheConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_get_completed_tasks_cache",
        argNames: [],
      );

  @override
  Future<DownloadGlobalStat> crateApiDownloaderApiDownloaderGetGlobalStats() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire
              .wire__crate__api__downloader_api__downloader_get_global_stats(
                port_,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_download_global_stat,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderGetGlobalStatsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderGetGlobalStatsConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_get_global_stats",
        argNames: [],
      );

  @override
  Future<DownloadTaskInfo> crateApiDownloaderApiDownloaderGetTaskInfo({
    required BigInt taskId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_usize(taskId);
          return wire
              .wire__crate__api__downloader_api__downloader_get_task_info(
                port_,
                arg0,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_download_task_info,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderGetTaskInfoConstMeta,
        argValues: [taskId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderGetTaskInfoConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_get_task_info",
        argNames: ["taskId"],
      );

  @override
  Future<bool> crateApiDownloaderApiDownloaderHasActiveTasks() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire
              .wire__crate__api__downloader_api__downloader_has_active_tasks(
                port_,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderHasActiveTasksConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderHasActiveTasksConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_has_active_tasks",
        argNames: [],
      );

  @override
  bool crateApiDownloaderApiDownloaderHasPendingSessionTasks({
    required String workingDir,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(workingDir);
          return wire
              .wire__crate__api__downloader_api__downloader_has_pending_session_tasks(
                arg0,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiDownloaderApiDownloaderHasPendingSessionTasksConstMeta,
        argValues: [workingDir],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDownloaderApiDownloaderHasPendingSessionTasksConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_has_pending_session_tasks",
        argNames: ["workingDir"],
      );

  @override
  Future<void> crateApiDownloaderApiDownloaderInit({
    required String workingDir,
    required String defaultDownloadDir,
    int? uploadLimitBps,
    int? downloadLimitBps,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(workingDir);
          var arg1 = cst_encode_String(defaultDownloadDir);
          var arg2 = cst_encode_opt_box_autoadd_u_32(uploadLimitBps);
          var arg3 = cst_encode_opt_box_autoadd_u_32(downloadLimitBps);
          return wire.wire__crate__api__downloader_api__downloader_init(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderInitConstMeta,
        argValues: [
          workingDir,
          defaultDownloadDir,
          uploadLimitBps,
          downloadLimitBps,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderInitConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_init",
        argNames: [
          "workingDir",
          "defaultDownloadDir",
          "uploadLimitBps",
          "downloadLimitBps",
        ],
      );

  @override
  bool crateApiDownloaderApiDownloaderIsInitialized() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire
              .wire__crate__api__downloader_api__downloader_is_initialized();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderIsInitializedConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderIsInitializedConstMeta =>
      const TaskConstMeta(debugName: "downloader_is_initialized", argNames: []);

  @override
  Future<bool> crateApiDownloaderApiDownloaderIsNameInTask({
    required String name,
    bool? downloadingOnly,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(name);
          var arg1 = cst_encode_opt_box_autoadd_bool(downloadingOnly);
          return wire
              .wire__crate__api__downloader_api__downloader_is_name_in_task(
                port_,
                arg0,
                arg1,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderIsNameInTaskConstMeta,
        argValues: [name, downloadingOnly],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderIsNameInTaskConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_is_name_in_task",
        argNames: ["name", "downloadingOnly"],
      );

  @override
  Future<void> crateApiDownloaderApiDownloaderPause({required BigInt taskId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_usize(taskId);
          return wire.wire__crate__api__downloader_api__downloader_pause(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderPauseConstMeta,
        argValues: [taskId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderPauseConstMeta =>
      const TaskConstMeta(debugName: "downloader_pause", argNames: ["taskId"]);

  @override
  Future<void> crateApiDownloaderApiDownloaderPauseAll() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__downloader_api__downloader_pause_all(
            port_,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderPauseAllConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderPauseAllConstMeta =>
      const TaskConstMeta(debugName: "downloader_pause_all", argNames: []);

  @override
  Future<void> crateApiDownloaderApiDownloaderRemove({
    required BigInt taskId,
    required bool deleteFiles,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_usize(taskId);
          var arg1 = cst_encode_bool(deleteFiles);
          return wire.wire__crate__api__downloader_api__downloader_remove(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderRemoveConstMeta,
        argValues: [taskId, deleteFiles],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderRemoveConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_remove",
        argNames: ["taskId", "deleteFiles"],
      );

  @override
  Future<int> crateApiDownloaderApiDownloaderRemoveCompletedTasks() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire
              .wire__crate__api__downloader_api__downloader_remove_completed_tasks(
                port_,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_u_32,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta:
            kCrateApiDownloaderApiDownloaderRemoveCompletedTasksConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDownloaderApiDownloaderRemoveCompletedTasksConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_remove_completed_tasks",
        argNames: [],
      );

  @override
  Future<void> crateApiDownloaderApiDownloaderResume({required BigInt taskId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_usize(taskId);
          return wire.wire__crate__api__downloader_api__downloader_resume(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderResumeConstMeta,
        argValues: [taskId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderResumeConstMeta =>
      const TaskConstMeta(debugName: "downloader_resume", argNames: ["taskId"]);

  @override
  Future<void> crateApiDownloaderApiDownloaderResumeAll() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__downloader_api__downloader_resume_all(
            port_,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderResumeAllConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderResumeAllConstMeta =>
      const TaskConstMeta(debugName: "downloader_resume_all", argNames: []);

  @override
  Future<void> crateApiDownloaderApiDownloaderShutdown() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__downloader_api__downloader_shutdown(
            port_,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderShutdownConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderShutdownConstMeta =>
      const TaskConstMeta(debugName: "downloader_shutdown", argNames: []);

  @override
  Future<void> crateApiDownloaderApiDownloaderStop() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__downloader_api__downloader_stop(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderStopConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDownloaderApiDownloaderStopConstMeta =>
      const TaskConstMeta(debugName: "downloader_stop", argNames: []);

  @override
  Future<void> crateApiDownloaderApiDownloaderUpdateSpeedLimits({
    int? uploadLimitBps,
    int? downloadLimitBps,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_opt_box_autoadd_u_32(uploadLimitBps);
          var arg1 = cst_encode_opt_box_autoadd_u_32(downloadLimitBps);
          return wire
              .wire__crate__api__downloader_api__downloader_update_speed_limits(
                port_,
                arg0,
                arg1,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiDownloaderApiDownloaderUpdateSpeedLimitsConstMeta,
        argValues: [uploadLimitBps, downloadLimitBps],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDownloaderApiDownloaderUpdateSpeedLimitsConstMeta =>
      const TaskConstMeta(
        debugName: "downloader_update_speed_limits",
        argNames: ["uploadLimitBps", "downloadLimitBps"],
      );

  @override
  Future<RustHttpResponse> crateApiHttpApiFetch({
    required MyMethod method,
    required String url,
    Map<String, String>? headers,
    Uint8List? inputData,
    String? withIpAddress,
    bool? withCustomDns,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_my_method(method);
          var arg1 = cst_encode_String(url);
          var arg2 = cst_encode_opt_Map_String_String_None(headers);
          var arg3 = cst_encode_opt_list_prim_u_8_strict(inputData);
          var arg4 = cst_encode_opt_String(withIpAddress);
          var arg5 = cst_encode_opt_box_autoadd_bool(withCustomDns);
          return wire.wire__crate__api__http_api__fetch(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_rust_http_response,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiHttpApiFetchConstMeta,
        argValues: [
          method,
          url,
          headers,
          inputData,
          withIpAddress,
          withCustomDns,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiHttpApiFetchConstMeta => const TaskConstMeta(
    debugName: "fetch",
    argNames: [
      "method",
      "url",
      "headers",
      "inputData",
      "withIpAddress",
      "withCustomDns",
    ],
  );

  @override
  Future<int> crateApiWin32ApiGetDiskPhysicalSectorSize({
    required String driveLetter,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(driveLetter);
          return wire
              .wire__crate__api__win32_api__get_disk_physical_sector_size(
                port_,
                arg0,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_u_32,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiGetDiskPhysicalSectorSizeConstMeta,
        argValues: [driveLetter],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiGetDiskPhysicalSectorSizeConstMeta =>
      const TaskConstMeta(
        debugName: "get_disk_physical_sector_size",
        argNames: ["driveLetter"],
      );

  @override
  Future<String?> crateApiHttpApiGetFasterUrl({
    required List<String> urls,
    String? pathSuffix,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_list_String(urls);
          var arg1 = cst_encode_opt_String(pathSuffix);
          return wire.wire__crate__api__http_api__get_faster_url(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_opt_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiHttpApiGetFasterUrlConstMeta,
        argValues: [urls, pathSuffix],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiHttpApiGetFasterUrlConstMeta =>
      const TaskConstMeta(
        debugName: "get_faster_url",
        argNames: ["urls", "pathSuffix"],
      );

  @override
  Future<String> crateApiWin32ApiGetGpuInfoFromRegistry() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__win32_api__get_gpu_info_from_registry(
            port_,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiGetGpuInfoFromRegistryConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiGetGpuInfoFromRegistryConstMeta =>
      const TaskConstMeta(
        debugName: "get_gpu_info_from_registry",
        argNames: [],
      );

  @override
  Future<int> crateApiWin32ApiGetNumberOfLogicalProcessors() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire
              .wire__crate__api__win32_api__get_number_of_logical_processors(
                port_,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_u_32,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiGetNumberOfLogicalProcessorsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiGetNumberOfLogicalProcessorsConstMeta =>
      const TaskConstMeta(
        debugName: "get_number_of_logical_processors",
        argNames: [],
      );

  @override
  Future<List<ProcessInfo>> crateApiWin32ApiGetProcessListByName({
    required String processName,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(processName);
          return wire.wire__crate__api__win32_api__get_process_list_by_name(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_process_info,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiGetProcessListByNameConstMeta,
        argValues: [processName],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiGetProcessListByNameConstMeta =>
      const TaskConstMeta(
        debugName: "get_process_list_by_name",
        argNames: ["processName"],
      );

  @override
  Future<int> crateApiWin32ApiGetProcessPidByName({
    required String processName,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(processName);
          return wire.wire__crate__api__win32_api__get_process_pid_by_name(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_i_32,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiGetProcessPidByNameConstMeta,
        argValues: [processName],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiGetProcessPidByNameConstMeta =>
      const TaskConstMeta(
        debugName: "get_process_pid_by_name",
        argNames: ["processName"],
      );

  @override
  Future<RsiLauncherAsarData> crateApiAsarApiGetRsiLauncherAsarData({
    required String asarPath,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(asarPath);
          return wire.wire__crate__api__asar_api__get_rsi_launcher_asar_data(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_rsi_launcher_asar_data,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiAsarApiGetRsiLauncherAsarDataConstMeta,
        argValues: [asarPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAsarApiGetRsiLauncherAsarDataConstMeta =>
      const TaskConstMeta(
        debugName: "get_rsi_launcher_asar_data",
        argNames: ["asarPath"],
      );

  @override
  Future<SystemInfo> crateApiWin32ApiGetSystemInfo() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__win32_api__get_system_info(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_system_info,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiGetSystemInfoConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiGetSystemInfoConstMeta =>
      const TaskConstMeta(debugName: "get_system_info", argNames: []);

  @override
  Future<BigInt> crateApiWin32ApiGetSystemMemorySizeGb() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__win32_api__get_system_memory_size_gb(
            port_,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_u_64,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiGetSystemMemorySizeGbConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiGetSystemMemorySizeGbConstMeta =>
      const TaskConstMeta(debugName: "get_system_memory_size_gb", argNames: []);

  @override
  Future<int> crateApiWin32ApiKillProcessByName({required String processName}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(processName);
          return wire.wire__crate__api__win32_api__kill_process_by_name(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_u_32,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiKillProcessByNameConstMeta,
        argValues: [processName],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiKillProcessByNameConstMeta =>
      const TaskConstMeta(
        debugName: "kill_process_by_name",
        argNames: ["processName"],
      );

  @override
  Future<void> crateApiOrtApiLoadTranslationModel({
    required String modelPath,
    required String modelKey,
    required String quantizationSuffix,
    required bool useXnnpack,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(modelPath);
          var arg1 = cst_encode_String(modelKey);
          var arg2 = cst_encode_String(quantizationSuffix);
          var arg3 = cst_encode_bool(useXnnpack);
          return wire.wire__crate__api__ort_api__load_translation_model(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiOrtApiLoadTranslationModelConstMeta,
        argValues: [modelPath, modelKey, quantizationSuffix, useXnnpack],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiOrtApiLoadTranslationModelConstMeta =>
      const TaskConstMeta(
        debugName: "load_translation_model",
        argNames: ["modelPath", "modelKey", "quantizationSuffix", "useXnnpack"],
      );

  @override
  Future<void> crateApiWin32ApiOpenDirWithExplorer({
    required String path,
    required bool isFile,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(path);
          var arg1 = cst_encode_bool(isFile);
          return wire.wire__crate__api__win32_api__open_dir_with_explorer(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiOpenDirWithExplorerConstMeta,
        argValues: [path, isFile],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiOpenDirWithExplorerConstMeta =>
      const TaskConstMeta(
        debugName: "open_dir_with_explorer",
        argNames: ["path", "isFile"],
      );

  @override
  Future<void> crateApiUnp4KApiP4KClose() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__unp4k_api__p4k_close(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiP4KCloseConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiP4KCloseConstMeta =>
      const TaskConstMeta(debugName: "p4k_close", argNames: []);

  @override
  Future<void> crateApiUnp4KApiP4KExtractToDisk({
    required String filePath,
    required String outputPath,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(filePath);
          var arg1 = cst_encode_String(outputPath);
          return wire.wire__crate__api__unp4k_api__p4k_extract_to_disk(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiP4KExtractToDiskConstMeta,
        argValues: [filePath, outputPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiP4KExtractToDiskConstMeta =>
      const TaskConstMeta(
        debugName: "p4k_extract_to_disk",
        argNames: ["filePath", "outputPath"],
      );

  @override
  Future<Uint8List> crateApiUnp4KApiP4KExtractToMemory({
    required String filePath,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(filePath);
          return wire.wire__crate__api__unp4k_api__p4k_extract_to_memory(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_prim_u_8_strict,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiP4KExtractToMemoryConstMeta,
        argValues: [filePath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiP4KExtractToMemoryConstMeta =>
      const TaskConstMeta(
        debugName: "p4k_extract_to_memory",
        argNames: ["filePath"],
      );

  @override
  Future<List<P4kFileItem>> crateApiUnp4KApiP4KGetAllFiles() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__unp4k_api__p4k_get_all_files(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_p_4_k_file_item,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiP4KGetAllFilesConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiP4KGetAllFilesConstMeta =>
      const TaskConstMeta(debugName: "p4k_get_all_files", argNames: []);

  @override
  Future<BigInt> crateApiUnp4KApiP4KGetFileCount() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__unp4k_api__p4k_get_file_count(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_usize,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiP4KGetFileCountConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiP4KGetFileCountConstMeta =>
      const TaskConstMeta(debugName: "p4k_get_file_count", argNames: []);

  @override
  Future<void> crateApiUnp4KApiP4KOpen({required String p4KPath}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(p4KPath);
          return wire.wire__crate__api__unp4k_api__p4k_open(port_, arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiUnp4KApiP4KOpenConstMeta,
        argValues: [p4KPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiUnp4KApiP4KOpenConstMeta =>
      const TaskConstMeta(debugName: "p4k_open", argNames: ["p4KPath"]);

  @override
  Future<void> crateApiWin32ApiRemoveNvmePatch() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire.wire__crate__api__win32_api__remove_nvme_patch(port_);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiRemoveNvmePatchConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiRemoveNvmePatchConstMeta =>
      const TaskConstMeta(debugName: "remove_nvme_patch", argNames: []);

  @override
  Future<String> crateApiWin32ApiResolveShortcut({required String lnkPath}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(lnkPath);
          return wire.wire__crate__api__win32_api__resolve_shortcut(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiResolveShortcutConstMeta,
        argValues: [lnkPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiResolveShortcutConstMeta =>
      const TaskConstMeta(debugName: "resolve_shortcut", argNames: ["lnkPath"]);

  @override
  Future<void> crateApiAsarApiRsiLauncherAsarDataWriteMainJs({
    required RsiLauncherAsarData that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_box_autoadd_rsi_launcher_asar_data(that);
          var arg1 = cst_encode_list_prim_u_8_loose(content);
          return wire
              .wire__crate__api__asar_api__rsi_launcher_asar_data_write_main_js(
                port_,
                arg0,
                arg1,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiAsarApiRsiLauncherAsarDataWriteMainJsConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAsarApiRsiLauncherAsarDataWriteMainJsConstMeta =>
      const TaskConstMeta(
        debugName: "rsi_launcher_asar_data_write_main_js",
        argNames: ["that", "content"],
      );

  @override
  Future<void> crateApiWin32ApiRunAsAdmin({
    required String program,
    required String args,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(program);
          var arg1 = cst_encode_String(args);
          return wire.wire__crate__api__win32_api__run_as_admin(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiRunAsAdminConstMeta,
        argValues: [program, args],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiRunAsAdminConstMeta => const TaskConstMeta(
    debugName: "run_as_admin",
    argNames: ["program", "args"],
  );

  @override
  Future<void> crateApiWin32ApiSendNotify({
    String? summary,
    String? body,
    String? appName,
    String? appId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_opt_String(summary);
          var arg1 = cst_encode_opt_String(body);
          var arg2 = cst_encode_opt_String(appName);
          var arg3 = cst_encode_opt_String(appId);
          return wire.wire__crate__api__win32_api__send_notify(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiSendNotifyConstMeta,
        argValues: [summary, body, appName, appId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiSendNotifyConstMeta => const TaskConstMeta(
    debugName: "send_notify",
    argNames: ["summary", "body", "appName", "appId"],
  );

  @override
  Future<void> crateApiHttpApiSetDefaultHeader({
    required Map<String, String> headers,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_Map_String_String_None(headers);
          return wire.wire__crate__api__http_api__set_default_header(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiHttpApiSetDefaultHeaderConstMeta,
        argValues: [headers],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiHttpApiSetDefaultHeaderConstMeta =>
      const TaskConstMeta(
        debugName: "set_default_header",
        argNames: ["headers"],
      );

  @override
  Future<bool> crateApiWin32ApiSetForegroundWindow({
    required String windowName,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(windowName);
          return wire.wire__crate__api__win32_api__set_foreground_window(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiSetForegroundWindowConstMeta,
        argValues: [windowName],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiSetForegroundWindowConstMeta =>
      const TaskConstMeta(
        debugName: "set_foreground_window",
        argNames: ["windowName"],
      );

  @override
  Stream<RsProcessStreamData> crateApiRsProcessStart({
    required String executable,
    required List<String> arguments,
    required String workingDirectory,
  }) {
    final streamSink = RustStreamSink<RsProcessStreamData>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            var arg0 = cst_encode_String(executable);
            var arg1 = cst_encode_list_String(arguments);
            var arg2 = cst_encode_String(workingDirectory);
            var arg3 = cst_encode_StreamSink_rs_process_stream_data_Dco(
              streamSink,
            );
            return wire.wire__crate__api__rs_process__start(
              port_,
              arg0,
              arg1,
              arg2,
              arg3,
            );
          },
          codec: DcoCodec(
            decodeSuccessData: dco_decode_unit,
            decodeErrorData: null,
          ),
          constMeta: kCrateApiRsProcessStartConstMeta,
          argValues: [executable, arguments, workingDirectory, streamSink],
          apiImpl: this,
        ),
      ),
    );
    return streamSink.stream;
  }

  TaskConstMeta get kCrateApiRsProcessStartConstMeta => const TaskConstMeta(
    debugName: "start",
    argNames: ["executable", "arguments", "workingDirectory", "streamSink"],
  );

  @override
  Future<void> crateApiWin32ApiStartProcess({
    required String program,
    required List<String> args,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(program);
          var arg1 = cst_encode_list_String(args);
          return wire.wire__crate__api__win32_api__start_process(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiWin32ApiStartProcessConstMeta,
        argValues: [program, args],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWin32ApiStartProcessConstMeta =>
      const TaskConstMeta(
        debugName: "start_process",
        argNames: ["program", "args"],
      );

  @override
  Future<String> crateApiOrtApiTranslateText({
    required String modelKey,
    required String text,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(modelKey);
          var arg1 = cst_encode_String(text);
          return wire.wire__crate__api__ort_api__translate_text(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiOrtApiTranslateTextConstMeta,
        argValues: [modelKey, text],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiOrtApiTranslateTextConstMeta =>
      const TaskConstMeta(
        debugName: "translate_text",
        argNames: ["modelKey", "text"],
      );

  @override
  Future<List<String>> crateApiOrtApiTranslateTextBatch({
    required String modelKey,
    required List<String> texts,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(modelKey);
          var arg1 = cst_encode_list_String(texts);
          return wire.wire__crate__api__ort_api__translate_text_batch(
            port_,
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_String,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiOrtApiTranslateTextBatchConstMeta,
        argValues: [modelKey, texts],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiOrtApiTranslateTextBatchConstMeta =>
      const TaskConstMeta(
        debugName: "translate_text_batch",
        argNames: ["modelKey", "texts"],
      );

  @override
  Future<void> crateApiOrtApiUnloadTranslationModel({
    required String modelKey,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_String(modelKey);
          return wire.wire__crate__api__ort_api__unload_translation_model(
            port_,
            arg0,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_AnyhowException,
        ),
        constMeta: kCrateApiOrtApiUnloadTranslationModelConstMeta,
        argValues: [modelKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiOrtApiUnloadTranslationModelConstMeta =>
      const TaskConstMeta(
        debugName: "unload_translation_model",
        argNames: ["modelKey"],
      );

  @override
  Future<WebViewConfiguration> crateApiWebviewApiWebViewConfigurationDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire
              .wire__crate__api__webview_api__web_view_configuration_default(
                port_,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_web_view_configuration,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWebviewApiWebViewConfigurationDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebViewConfigurationDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "web_view_configuration_default",
        argNames: [],
      );

  @override
  Future<WebViewNavigationState>
  crateApiWebviewApiWebViewNavigationStateDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          return wire
              .wire__crate__api__webview_api__web_view_navigation_state_default(
                port_,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_web_view_navigation_state,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWebviewApiWebViewNavigationStateDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebViewNavigationStateDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "web_view_navigation_state_default",
        argNames: [],
      );

  @override
  void crateApiWebviewApiWebviewClose({required String id}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(id);
          return wire.wire__crate__api__webview_api__webview_close(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiWebviewApiWebviewCloseConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewCloseConstMeta =>
      const TaskConstMeta(debugName: "webview_close", argNames: ["id"]);

  @override
  String crateApiWebviewApiWebviewCreate({
    required WebViewConfiguration config,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_box_autoadd_web_view_configuration(config);
          return wire.wire__crate__api__webview_api__webview_create(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_String,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiWebviewApiWebviewCreateConstMeta,
        argValues: [config],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewCreateConstMeta =>
      const TaskConstMeta(debugName: "webview_create", argNames: ["config"]);

  @override
  void crateApiWebviewApiWebviewExecuteScript({
    required String id,
    required String script,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(id);
          var arg1 = cst_encode_String(script);
          return wire.wire__crate__api__webview_api__webview_execute_script(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiWebviewApiWebviewExecuteScriptConstMeta,
        argValues: [id, script],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewExecuteScriptConstMeta =>
      const TaskConstMeta(
        debugName: "webview_execute_script",
        argNames: ["id", "script"],
      );

  @override
  WebViewNavigationState crateApiWebviewApiWebviewGetState({
    required String id,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(id);
          return wire.wire__crate__api__webview_api__webview_get_state(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_web_view_navigation_state,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiWebviewApiWebviewGetStateConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewGetStateConstMeta =>
      const TaskConstMeta(debugName: "webview_get_state", argNames: ["id"]);

  @override
  void crateApiWebviewApiWebviewGoBack({required String id}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(id);
          return wire.wire__crate__api__webview_api__webview_go_back(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiWebviewApiWebviewGoBackConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewGoBackConstMeta =>
      const TaskConstMeta(debugName: "webview_go_back", argNames: ["id"]);

  @override
  void crateApiWebviewApiWebviewGoForward({required String id}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(id);
          return wire.wire__crate__api__webview_api__webview_go_forward(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiWebviewApiWebviewGoForwardConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewGoForwardConstMeta =>
      const TaskConstMeta(debugName: "webview_go_forward", argNames: ["id"]);

  @override
  bool crateApiWebviewApiWebviewIsClosed({required String id}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(id);
          return wire.wire__crate__api__webview_api__webview_is_closed(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWebviewApiWebviewIsClosedConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewIsClosedConstMeta =>
      const TaskConstMeta(debugName: "webview_is_closed", argNames: ["id"]);

  @override
  List<String> crateApiWebviewApiWebviewListAll() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          return wire.wire__crate__api__webview_api__webview_list_all();
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWebviewApiWebviewListAllConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewListAllConstMeta =>
      const TaskConstMeta(debugName: "webview_list_all", argNames: []);

  @override
  void crateApiWebviewApiWebviewNavigate({
    required String id,
    required String url,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(id);
          var arg1 = cst_encode_String(url);
          return wire.wire__crate__api__webview_api__webview_navigate(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiWebviewApiWebviewNavigateConstMeta,
        argValues: [id, url],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewNavigateConstMeta =>
      const TaskConstMeta(
        debugName: "webview_navigate",
        argNames: ["id", "url"],
      );

  @override
  List<WebViewEvent> crateApiWebviewApiWebviewPollEvents({required String id}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(id);
          return wire.wire__crate__api__webview_api__webview_poll_events(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_list_web_view_event,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWebviewApiWebviewPollEventsConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewPollEventsConstMeta =>
      const TaskConstMeta(debugName: "webview_poll_events", argNames: ["id"]);

  @override
  void crateApiWebviewApiWebviewReload({required String id}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(id);
          return wire.wire__crate__api__webview_api__webview_reload(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiWebviewApiWebviewReloadConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewReloadConstMeta =>
      const TaskConstMeta(debugName: "webview_reload", argNames: ["id"]);

  @override
  void crateApiWebviewApiWebviewSetVisibility({
    required String id,
    required bool visible,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(id);
          var arg1 = cst_encode_bool(visible);
          return wire.wire__crate__api__webview_api__webview_set_visibility(
            arg0,
            arg1,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiWebviewApiWebviewSetVisibilityConstMeta,
        argValues: [id, visible],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewSetVisibilityConstMeta =>
      const TaskConstMeta(
        debugName: "webview_set_visibility",
        argNames: ["id", "visible"],
      );

  @override
  void crateApiWebviewApiWebviewSetWindowPosition({
    required String id,
    required int x,
    required int y,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(id);
          var arg1 = cst_encode_i_32(x);
          var arg2 = cst_encode_i_32(y);
          return wire
              .wire__crate__api__webview_api__webview_set_window_position(
                arg0,
                arg1,
                arg2,
              );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiWebviewApiWebviewSetWindowPositionConstMeta,
        argValues: [id, x, y],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewSetWindowPositionConstMeta =>
      const TaskConstMeta(
        debugName: "webview_set_window_position",
        argNames: ["id", "x", "y"],
      );

  @override
  void crateApiWebviewApiWebviewSetWindowSize({
    required String id,
    required int width,
    required int height,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(id);
          var arg1 = cst_encode_u_32(width);
          var arg2 = cst_encode_u_32(height);
          return wire.wire__crate__api__webview_api__webview_set_window_size(
            arg0,
            arg1,
            arg2,
          );
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiWebviewApiWebviewSetWindowSizeConstMeta,
        argValues: [id, width, height],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewSetWindowSizeConstMeta =>
      const TaskConstMeta(
        debugName: "webview_set_window_size",
        argNames: ["id", "width", "height"],
      );

  @override
  void crateApiWebviewApiWebviewStop({required String id}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          var arg0 = cst_encode_String(id);
          return wire.wire__crate__api__webview_api__webview_stop(arg0);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: dco_decode_String,
        ),
        constMeta: kCrateApiWebviewApiWebviewStopConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWebviewApiWebviewStopConstMeta =>
      const TaskConstMeta(debugName: "webview_stop", argNames: ["id"]);

  @override
  Future<void> crateApiRsProcessWrite({
    required int rsPid,
    required String data,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          var arg0 = cst_encode_u_32(rsPid);
          var arg1 = cst_encode_String(data);
          return wire.wire__crate__api__rs_process__write(port_, arg0, arg1);
        },
        codec: DcoCodec(
          decodeSuccessData: dco_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiRsProcessWriteConstMeta,
        argValues: [rsPid, data],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiRsProcessWriteConstMeta =>
      const TaskConstMeta(debugName: "write", argNames: ["rsPid", "data"]);

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  Map<String, String> dco_decode_Map_String_String_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
      dco_decode_list_record_string_string(
        raw,
      ).map((e) => MapEntry(e.$1, e.$2)),
    );
  }

  @protected
  RustStreamSink<RsProcessStreamData>
  dco_decode_StreamSink_rs_process_stream_data_Dco(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  RsiLauncherAsarData dco_decode_box_autoadd_rsi_launcher_asar_data(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_rsi_launcher_asar_data(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  WebViewConfiguration dco_decode_box_autoadd_web_view_configuration(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_web_view_configuration(raw);
  }

  @protected
  DcbRecordItem dco_decode_dcb_record_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return DcbRecordItem(
      path: dco_decode_String(arr[0]),
      index: dco_decode_usize(arr[1]),
    );
  }

  @protected
  DcbSearchMatch dco_decode_dcb_search_match(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return DcbSearchMatch(
      lineNumber: dco_decode_usize(arr[0]),
      lineContent: dco_decode_String(arr[1]),
    );
  }

  @protected
  DcbSearchResult dco_decode_dcb_search_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return DcbSearchResult(
      path: dco_decode_String(arr[0]),
      index: dco_decode_usize(arr[1]),
      matches: dco_decode_list_dcb_search_match(arr[2]),
    );
  }

  @protected
  DownloadGlobalStat dco_decode_download_global_stat(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return DownloadGlobalStat(
      downloadSpeed: dco_decode_u_64(arr[0]),
      uploadSpeed: dco_decode_u_64(arr[1]),
      numActive: dco_decode_usize(arr[2]),
      numWaiting: dco_decode_usize(arr[3]),
    );
  }

  @protected
  DownloadTaskInfo dco_decode_download_task_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return DownloadTaskInfo(
      id: dco_decode_usize(arr[0]),
      name: dco_decode_String(arr[1]),
      status: dco_decode_download_task_status(arr[2]),
      totalBytes: dco_decode_u_64(arr[3]),
      downloadedBytes: dco_decode_u_64(arr[4]),
      uploadedBytes: dco_decode_u_64(arr[5]),
      downloadSpeed: dco_decode_u_64(arr[6]),
      uploadSpeed: dco_decode_u_64(arr[7]),
      progress: dco_decode_f_64(arr[8]),
      numPeers: dco_decode_usize(arr[9]),
      outputFolder: dco_decode_String(arr[10]),
    );
  }

  @protected
  DownloadTaskStatus dco_decode_download_task_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DownloadTaskStatus.values[raw as int];
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<DcbRecordItem> dco_decode_list_dcb_record_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_dcb_record_item).toList();
  }

  @protected
  List<DcbSearchMatch> dco_decode_list_dcb_search_match(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_dcb_search_match).toList();
  }

  @protected
  List<DcbSearchResult> dco_decode_list_dcb_search_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_dcb_search_result).toList();
  }

  @protected
  List<DownloadTaskInfo> dco_decode_list_download_task_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_download_task_info).toList();
  }

  @protected
  List<P4kFileItem> dco_decode_list_p_4_k_file_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_p_4_k_file_item).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<ProcessInfo> dco_decode_list_process_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_process_info).toList();
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<WebViewEvent> dco_decode_list_web_view_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_web_view_event).toList();
  }

  @protected
  MyHttpVersion dco_decode_my_http_version(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MyHttpVersion.values[raw as int];
  }

  @protected
  MyMethod dco_decode_my_method(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MyMethod.values[raw as int];
  }

  @protected
  Map<String, String>? dco_decode_opt_Map_String_String_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_Map_String_String_None(raw);
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  List<String>? dco_decode_opt_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_String(raw);
  }

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_8_strict(raw);
  }

  @protected
  P4kFileItem dco_decode_p_4_k_file_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return P4kFileItem(
      name: dco_decode_String(arr[0]),
      isDirectory: dco_decode_bool(arr[1]),
      size: dco_decode_u_64(arr[2]),
      compressedSize: dco_decode_u_64(arr[3]),
      dateModified: dco_decode_i_64(arr[4]),
    );
  }

  @protected
  ProcessInfo dco_decode_process_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ProcessInfo(
      pid: dco_decode_u_32(arr[0]),
      name: dco_decode_String(arr[1]),
      path: dco_decode_String(arr[2]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_String(arr[0]), dco_decode_String(arr[1]));
  }

  @protected
  RsProcessStreamData dco_decode_rs_process_stream_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RsProcessStreamData(
      dataType: dco_decode_rs_process_stream_data_type(arr[0]),
      data: dco_decode_String(arr[1]),
      rsPid: dco_decode_u_32(arr[2]),
    );
  }

  @protected
  RsProcessStreamDataType dco_decode_rs_process_stream_data_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return RsProcessStreamDataType.values[raw as int];
  }

  @protected
  RsiLauncherAsarData dco_decode_rsi_launcher_asar_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RsiLauncherAsarData(
      asarPath: dco_decode_String(arr[0]),
      mainJsPath: dco_decode_String(arr[1]),
      mainJsContent: dco_decode_list_prim_u_8_strict(arr[2]),
    );
  }

  @protected
  RustHttpResponse dco_decode_rust_http_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return RustHttpResponse(
      statusCode: dco_decode_u_16(arr[0]),
      headers: dco_decode_Map_String_String_None(arr[1]),
      url: dco_decode_String(arr[2]),
      contentLength: dco_decode_opt_box_autoadd_u_64(arr[3]),
      version: dco_decode_my_http_version(arr[4]),
      remoteAddr: dco_decode_String(arr[5]),
      data: dco_decode_opt_list_prim_u_8_strict(arr[6]),
    );
  }

  @protected
  SystemInfo dco_decode_system_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return SystemInfo(
      osName: dco_decode_String(arr[0]),
      cpuName: dco_decode_String(arr[1]),
      gpuInfo: dco_decode_String(arr[2]),
      diskInfo: dco_decode_String(arr[3]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WebViewConfiguration dco_decode_web_view_configuration(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return WebViewConfiguration(
      title: dco_decode_String(arr[0]),
      width: dco_decode_u_32(arr[1]),
      height: dco_decode_u_32(arr[2]),
      userDataFolder: dco_decode_opt_String(arr[3]),
      enableDevtools: dco_decode_bool(arr[4]),
      transparent: dco_decode_bool(arr[5]),
      userAgent: dco_decode_opt_String(arr[6]),
    );
  }

  @protected
  WebViewEvent dco_decode_web_view_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return WebViewEvent_NavigationStarted(url: dco_decode_String(raw[1]));
      case 1:
        return WebViewEvent_NavigationCompleted(url: dco_decode_String(raw[1]));
      case 2:
        return WebViewEvent_TitleChanged(title: dco_decode_String(raw[1]));
      case 3:
        return WebViewEvent_WebMessage(message: dco_decode_String(raw[1]));
      case 4:
        return WebViewEvent_WindowClosed();
      case 5:
        return WebViewEvent_Error(message: dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  WebViewNavigationState dco_decode_web_view_navigation_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return WebViewNavigationState(
      url: dco_decode_String(arr[0]),
      title: dco_decode_String(arr[1]),
      canGoBack: dco_decode_bool(arr[2]),
      canGoForward: dco_decode_bool(arr[3]),
      isLoading: dco_decode_bool(arr[4]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  Map<String, String> sse_decode_Map_String_String_None(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_string(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  RustStreamSink<RsProcessStreamData>
  sse_decode_StreamSink_rs_process_stream_data_Dco(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  RsiLauncherAsarData sse_decode_box_autoadd_rsi_launcher_asar_data(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_rsi_launcher_asar_data(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  WebViewConfiguration sse_decode_box_autoadd_web_view_configuration(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_web_view_configuration(deserializer));
  }

  @protected
  DcbRecordItem sse_decode_dcb_record_item(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_path = sse_decode_String(deserializer);
    var var_index = sse_decode_usize(deserializer);
    return DcbRecordItem(path: var_path, index: var_index);
  }

  @protected
  DcbSearchMatch sse_decode_dcb_search_match(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lineNumber = sse_decode_usize(deserializer);
    var var_lineContent = sse_decode_String(deserializer);
    return DcbSearchMatch(
      lineNumber: var_lineNumber,
      lineContent: var_lineContent,
    );
  }

  @protected
  DcbSearchResult sse_decode_dcb_search_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_path = sse_decode_String(deserializer);
    var var_index = sse_decode_usize(deserializer);
    var var_matches = sse_decode_list_dcb_search_match(deserializer);
    return DcbSearchResult(
      path: var_path,
      index: var_index,
      matches: var_matches,
    );
  }

  @protected
  DownloadGlobalStat sse_decode_download_global_stat(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_downloadSpeed = sse_decode_u_64(deserializer);
    var var_uploadSpeed = sse_decode_u_64(deserializer);
    var var_numActive = sse_decode_usize(deserializer);
    var var_numWaiting = sse_decode_usize(deserializer);
    return DownloadGlobalStat(
      downloadSpeed: var_downloadSpeed,
      uploadSpeed: var_uploadSpeed,
      numActive: var_numActive,
      numWaiting: var_numWaiting,
    );
  }

  @protected
  DownloadTaskInfo sse_decode_download_task_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_usize(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_status = sse_decode_download_task_status(deserializer);
    var var_totalBytes = sse_decode_u_64(deserializer);
    var var_downloadedBytes = sse_decode_u_64(deserializer);
    var var_uploadedBytes = sse_decode_u_64(deserializer);
    var var_downloadSpeed = sse_decode_u_64(deserializer);
    var var_uploadSpeed = sse_decode_u_64(deserializer);
    var var_progress = sse_decode_f_64(deserializer);
    var var_numPeers = sse_decode_usize(deserializer);
    var var_outputFolder = sse_decode_String(deserializer);
    return DownloadTaskInfo(
      id: var_id,
      name: var_name,
      status: var_status,
      totalBytes: var_totalBytes,
      downloadedBytes: var_downloadedBytes,
      uploadedBytes: var_uploadedBytes,
      downloadSpeed: var_downloadSpeed,
      uploadSpeed: var_uploadSpeed,
      progress: var_progress,
      numPeers: var_numPeers,
      outputFolder: var_outputFolder,
    );
  }

  @protected
  DownloadTaskStatus sse_decode_download_task_status(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return DownloadTaskStatus.values[inner];
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<DcbRecordItem> sse_decode_list_dcb_record_item(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DcbRecordItem>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_dcb_record_item(deserializer));
    }
    return ans_;
  }

  @protected
  List<DcbSearchMatch> sse_decode_list_dcb_search_match(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DcbSearchMatch>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_dcb_search_match(deserializer));
    }
    return ans_;
  }

  @protected
  List<DcbSearchResult> sse_decode_list_dcb_search_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DcbSearchResult>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_dcb_search_result(deserializer));
    }
    return ans_;
  }

  @protected
  List<DownloadTaskInfo> sse_decode_list_download_task_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DownloadTaskInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_download_task_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<P4kFileItem> sse_decode_list_p_4_k_file_item(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <P4kFileItem>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_p_4_k_file_item(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<ProcessInfo> sse_decode_list_process_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ProcessInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_process_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<WebViewEvent> sse_decode_list_web_view_event(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WebViewEvent>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_web_view_event(deserializer));
    }
    return ans_;
  }

  @protected
  MyHttpVersion sse_decode_my_http_version(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return MyHttpVersion.values[inner];
  }

  @protected
  MyMethod sse_decode_my_method(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return MyMethod.values[inner];
  }

  @protected
  Map<String, String>? sse_decode_opt_Map_String_String_None(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_Map_String_String_None(deserializer));
    } else {
      return null;
    }
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<String>? sse_decode_opt_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_8_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  P4kFileItem sse_decode_p_4_k_file_item(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_isDirectory = sse_decode_bool(deserializer);
    var var_size = sse_decode_u_64(deserializer);
    var var_compressedSize = sse_decode_u_64(deserializer);
    var var_dateModified = sse_decode_i_64(deserializer);
    return P4kFileItem(
      name: var_name,
      isDirectory: var_isDirectory,
      size: var_size,
      compressedSize: var_compressedSize,
      dateModified: var_dateModified,
    );
  }

  @protected
  ProcessInfo sse_decode_process_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_pid = sse_decode_u_32(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_path = sse_decode_String(deserializer);
    return ProcessInfo(pid: var_pid, name: var_name, path: var_path);
  }

  @protected
  (String, String) sse_decode_record_string_string(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  RsProcessStreamData sse_decode_rs_process_stream_data(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_dataType = sse_decode_rs_process_stream_data_type(deserializer);
    var var_data = sse_decode_String(deserializer);
    var var_rsPid = sse_decode_u_32(deserializer);
    return RsProcessStreamData(
      dataType: var_dataType,
      data: var_data,
      rsPid: var_rsPid,
    );
  }

  @protected
  RsProcessStreamDataType sse_decode_rs_process_stream_data_type(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return RsProcessStreamDataType.values[inner];
  }

  @protected
  RsiLauncherAsarData sse_decode_rsi_launcher_asar_data(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_asarPath = sse_decode_String(deserializer);
    var var_mainJsPath = sse_decode_String(deserializer);
    var var_mainJsContent = sse_decode_list_prim_u_8_strict(deserializer);
    return RsiLauncherAsarData(
      asarPath: var_asarPath,
      mainJsPath: var_mainJsPath,
      mainJsContent: var_mainJsContent,
    );
  }

  @protected
  RustHttpResponse sse_decode_rust_http_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_statusCode = sse_decode_u_16(deserializer);
    var var_headers = sse_decode_Map_String_String_None(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_contentLength = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_version = sse_decode_my_http_version(deserializer);
    var var_remoteAddr = sse_decode_String(deserializer);
    var var_data = sse_decode_opt_list_prim_u_8_strict(deserializer);
    return RustHttpResponse(
      statusCode: var_statusCode,
      headers: var_headers,
      url: var_url,
      contentLength: var_contentLength,
      version: var_version,
      remoteAddr: var_remoteAddr,
      data: var_data,
    );
  }

  @protected
  SystemInfo sse_decode_system_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_osName = sse_decode_String(deserializer);
    var var_cpuName = sse_decode_String(deserializer);
    var var_gpuInfo = sse_decode_String(deserializer);
    var var_diskInfo = sse_decode_String(deserializer);
    return SystemInfo(
      osName: var_osName,
      cpuName: var_cpuName,
      gpuInfo: var_gpuInfo,
      diskInfo: var_diskInfo,
    );
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WebViewConfiguration sse_decode_web_view_configuration(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_title = sse_decode_String(deserializer);
    var var_width = sse_decode_u_32(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    var var_userDataFolder = sse_decode_opt_String(deserializer);
    var var_enableDevtools = sse_decode_bool(deserializer);
    var var_transparent = sse_decode_bool(deserializer);
    var var_userAgent = sse_decode_opt_String(deserializer);
    return WebViewConfiguration(
      title: var_title,
      width: var_width,
      height: var_height,
      userDataFolder: var_userDataFolder,
      enableDevtools: var_enableDevtools,
      transparent: var_transparent,
      userAgent: var_userAgent,
    );
  }

  @protected
  WebViewEvent sse_decode_web_view_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_url = sse_decode_String(deserializer);
        return WebViewEvent_NavigationStarted(url: var_url);
      case 1:
        var var_url = sse_decode_String(deserializer);
        return WebViewEvent_NavigationCompleted(url: var_url);
      case 2:
        var var_title = sse_decode_String(deserializer);
        return WebViewEvent_TitleChanged(title: var_title);
      case 3:
        var var_message = sse_decode_String(deserializer);
        return WebViewEvent_WebMessage(message: var_message);
      case 4:
        return WebViewEvent_WindowClosed();
      case 5:
        var var_message = sse_decode_String(deserializer);
        return WebViewEvent_Error(message: var_message);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  WebViewNavigationState sse_decode_web_view_navigation_state(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_canGoBack = sse_decode_bool(deserializer);
    var var_canGoForward = sse_decode_bool(deserializer);
    var var_isLoading = sse_decode_bool(deserializer);
    return WebViewNavigationState(
      url: var_url,
      title: var_title,
      canGoBack: var_canGoBack,
      canGoForward: var_canGoForward,
      isLoading: var_isLoading,
    );
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_download_task_status(DownloadTaskStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  double cst_encode_f_64(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_my_http_version(MyHttpVersion raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_my_method(MyMethod raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_rs_process_stream_data_type(RsProcessStreamDataType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_Map_String_String_None(
    Map<String, String> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_string(
      self.entries.map((e) => (e.key, e.value)).toList(),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_rs_process_stream_data_Dco(
    RustStreamSink<RsProcessStreamData> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: DcoCodec(
          decodeSuccessData: dco_decode_rs_process_stream_data,
          decodeErrorData: dco_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_rsi_launcher_asar_data(
    RsiLauncherAsarData self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rsi_launcher_asar_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_web_view_configuration(
    WebViewConfiguration self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_web_view_configuration(self, serializer);
  }

  @protected
  void sse_encode_dcb_record_item(
    DcbRecordItem self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.path, serializer);
    sse_encode_usize(self.index, serializer);
  }

  @protected
  void sse_encode_dcb_search_match(
    DcbSearchMatch self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.lineNumber, serializer);
    sse_encode_String(self.lineContent, serializer);
  }

  @protected
  void sse_encode_dcb_search_result(
    DcbSearchResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.path, serializer);
    sse_encode_usize(self.index, serializer);
    sse_encode_list_dcb_search_match(self.matches, serializer);
  }

  @protected
  void sse_encode_download_global_stat(
    DownloadGlobalStat self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.downloadSpeed, serializer);
    sse_encode_u_64(self.uploadSpeed, serializer);
    sse_encode_usize(self.numActive, serializer);
    sse_encode_usize(self.numWaiting, serializer);
  }

  @protected
  void sse_encode_download_task_info(
    DownloadTaskInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_download_task_status(self.status, serializer);
    sse_encode_u_64(self.totalBytes, serializer);
    sse_encode_u_64(self.downloadedBytes, serializer);
    sse_encode_u_64(self.uploadedBytes, serializer);
    sse_encode_u_64(self.downloadSpeed, serializer);
    sse_encode_u_64(self.uploadSpeed, serializer);
    sse_encode_f_64(self.progress, serializer);
    sse_encode_usize(self.numPeers, serializer);
    sse_encode_String(self.outputFolder, serializer);
  }

  @protected
  void sse_encode_download_task_status(
    DownloadTaskStatus self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_dcb_record_item(
    List<DcbRecordItem> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_dcb_record_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_dcb_search_match(
    List<DcbSearchMatch> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_dcb_search_match(item, serializer);
    }
  }

  @protected
  void sse_encode_list_dcb_search_result(
    List<DcbSearchResult> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_dcb_search_result(item, serializer);
    }
  }

  @protected
  void sse_encode_list_download_task_info(
    List<DownloadTaskInfo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_download_task_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_p_4_k_file_item(
    List<P4kFileItem> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_p_4_k_file_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
    List<int> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(
      self is Uint8List ? self : Uint8List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_process_info(
    List<ProcessInfo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_process_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_string(
    List<(String, String)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_web_view_event(
    List<WebViewEvent> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_web_view_event(item, serializer);
    }
  }

  @protected
  void sse_encode_my_http_version(
    MyHttpVersion self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_my_method(MyMethod self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_Map_String_String_None(
    Map<String, String>? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_Map_String_String_None(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_String(
    List<String>? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_8_strict(
    Uint8List? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_8_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_p_4_k_file_item(P4kFileItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_bool(self.isDirectory, serializer);
    sse_encode_u_64(self.size, serializer);
    sse_encode_u_64(self.compressedSize, serializer);
    sse_encode_i_64(self.dateModified, serializer);
  }

  @protected
  void sse_encode_process_info(ProcessInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.pid, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.path, serializer);
  }

  @protected
  void sse_encode_record_string_string(
    (String, String) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_rs_process_stream_data(
    RsProcessStreamData self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_rs_process_stream_data_type(self.dataType, serializer);
    sse_encode_String(self.data, serializer);
    sse_encode_u_32(self.rsPid, serializer);
  }

  @protected
  void sse_encode_rs_process_stream_data_type(
    RsProcessStreamDataType self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_rsi_launcher_asar_data(
    RsiLauncherAsarData self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.asarPath, serializer);
    sse_encode_String(self.mainJsPath, serializer);
    sse_encode_list_prim_u_8_strict(self.mainJsContent, serializer);
  }

  @protected
  void sse_encode_rust_http_response(
    RustHttpResponse self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self.statusCode, serializer);
    sse_encode_Map_String_String_None(self.headers, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_opt_box_autoadd_u_64(self.contentLength, serializer);
    sse_encode_my_http_version(self.version, serializer);
    sse_encode_String(self.remoteAddr, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.data, serializer);
  }

  @protected
  void sse_encode_system_info(SystemInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.osName, serializer);
    sse_encode_String(self.cpuName, serializer);
    sse_encode_String(self.gpuInfo, serializer);
    sse_encode_String(self.diskInfo, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_web_view_configuration(
    WebViewConfiguration self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.title, serializer);
    sse_encode_u_32(self.width, serializer);
    sse_encode_u_32(self.height, serializer);
    sse_encode_opt_String(self.userDataFolder, serializer);
    sse_encode_bool(self.enableDevtools, serializer);
    sse_encode_bool(self.transparent, serializer);
    sse_encode_opt_String(self.userAgent, serializer);
  }

  @protected
  void sse_encode_web_view_event(WebViewEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case WebViewEvent_NavigationStarted(url: final url):
        sse_encode_i_32(0, serializer);
        sse_encode_String(url, serializer);
      case WebViewEvent_NavigationCompleted(url: final url):
        sse_encode_i_32(1, serializer);
        sse_encode_String(url, serializer);
      case WebViewEvent_TitleChanged(title: final title):
        sse_encode_i_32(2, serializer);
        sse_encode_String(title, serializer);
      case WebViewEvent_WebMessage(message: final message):
        sse_encode_i_32(3, serializer);
        sse_encode_String(message, serializer);
      case WebViewEvent_WindowClosed():
        sse_encode_i_32(4, serializer);
      case WebViewEvent_Error(message: final message):
        sse_encode_i_32(5, serializer);
        sse_encode_String(message, serializer);
    }
  }

  @protected
  void sse_encode_web_view_navigation_state(
    WebViewNavigationState self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_bool(self.canGoBack, serializer);
    sse_encode_bool(self.canGoForward, serializer);
    sse_encode_bool(self.isLoading, serializer);
  }
}
